<!doctype html>
<meta charset="utf-8" />
<title>Call</title>
<link rel="stylesheet" href="/styles.css">

<div class="container">
    <div class="card">
        <h1>Audio Call</h1>
        <div class="actions" style="margin:10px 0 12px">
            <button id="join" class="btn">ðŸ”Š Join call</button>
            <button id="mute" class="btn secondary" disabled>ÐœÐ¸Ðº Ð²Ñ‹ÐºÐ»ÑŽÑ‡Ð¸Ñ‚ÑŒ</button>
            <button id="leave" class="btn danger" disabled>Ð’Ñ‹Ð¹Ñ‚Ð¸</button>
            <span class="tag" id="net">ICE: â€”</span>
        </div>
        <div id="status" class="note">Ð“Ð¾Ñ‚Ð¾Ð²Ð¾ Ðº Ð¿Ð¾Ð´ÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸ÑŽâ€¦</div>
        <hr>
        <div id="logs" class="mono"></div>
    </div>
</div>

<script>
    const log = (...a)=>{ const l=document.getElementById('logs'); l.textContent += a.join(' ')+'\n'; console.log(...a) }

    const params = new URLSearchParams(location.search)
    const token = params.get('t')
    const statusEl = document.getElementById('status')
    const netTag = document.getElementById('net')
    if (!token) statusEl.textContent = 'ÐÐµÑ‚ Ñ‚Ð¾ÐºÐµÐ½Ð°'

    const peers = new Map()
    const streams = new Map()
    let localStream, ws

    const pcConfig = {
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' }
        ]
    }

    document.getElementById('join').onclick = start

    async function start() {
        document.getElementById('join').disabled = true
        statusEl.textContent = 'ÐžÐ¶Ð¸Ð´Ð°ÐµÐ¼ Ð´Ð¾ÑÑ‚ÑƒÐ¿ Ðº Ð¼Ð¸ÐºÑ€Ð¾Ñ„Ð¾Ð½Ñƒâ€¦'
        try {
            localStream = await navigator.mediaDevices.getUserMedia({
                audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true },
                video: false
            })
        } catch (e) {
            statusEl.textContent = 'ÐœÐ¸ÐºÑ€Ð¾Ñ„Ð¾Ð½ Ð¾Ñ‚ÐºÐ»Ð¾Ð½Ñ‘Ð½'
            log('getUserMedia error:', e)
            return
        }

        ws = new WebSocket((location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/ws?token=' + encodeURIComponent(token))
        ws.onopen = ()=> log('ws open')
        ws.onclose = ()=> { log('ws close'); statusEl.textContent='ÐžÑ‚ÐºÐ»ÑŽÑ‡ÐµÐ½' }

        let selfId = null
        ws.onmessage = async (ev) => {
            const msg = JSON.parse(ev.data)
            if (msg.type === 'hello') {
                selfId = msg.peerId
                statusEl.textContent = 'ÐŸÐ¾Ð´ÐºÐ»ÑŽÑ‡ÐµÐ½. Ð¡Ð¾Ð±ÐµÑÐµÐ´Ð½Ð¸ÐºÐ¾Ð²: ' + msg.peers.length
                for (const other of msg.peers) await connectTo(other, true)
                document.getElementById('mute').disabled = false
                document.getElementById('leave').disabled = false
            } else if (msg.type === 'peer-join') {
                log('peer-join', msg.peerId)
                await connectTo(msg.peerId, false) // Ð¶Ð´Ñ‘Ð¼ offer Ð¾Ñ‚ Ð½Ð¾Ð²Ð¾Ð³Ð¾ â€” Ð±ÐµÐ· glare
            } else if (msg.type === 'peer-leave') {
                log('peer-leave', msg.peerId)
                closePeer(msg.peerId)
            } else if (msg.type === 'signal') {
                await handleSignal(msg.from, msg.data)
            }
        }

        document.getElementById('mute').onclick = () => {
            const tr = localStream.getAudioTracks()[0]
            tr.enabled = !tr.enabled
            document.getElementById('mute').textContent = tr.enabled ? 'ÐœÐ¸Ðº Ð²Ñ‹ÐºÐ»ÑŽÑ‡Ð¸Ñ‚ÑŒ' : 'ÐœÐ¸Ðº Ð²ÐºÐ»ÑŽÑ‡Ð¸Ñ‚ÑŒ'
        }
        document.getElementById('leave').onclick = () => {
            try { ws && ws.close() } catch {}
            for (const id of peers.keys()) closePeer(id)
            location.href = '/'
        }
    }

    async function connectTo(peerId, isInitiator) {
        if (peers.has(peerId)) return peers.get(peerId)

        const pc = new RTCPeerConnection(pcConfig)
        peers.set(peerId, pc)

        pc.oniceconnectionstatechange = ()=> {
            log('iceState', peerId, pc.iceConnectionState)
            netTag.textContent = 'ICE: ' + pc.iceConnectionState
        }
        pc.onconnectionstatechange = ()=> log('connState', peerId, pc.connectionState)

        localStream.getTracks().forEach(t => pc.addTrack(t, localStream))

        pc.ontrack = (e) => {
            let a = streams.get(peerId)
            if (!a) {
                a = new Audio()
                a.autoplay = true
                a.playsInline = true
                streams.set(peerId, a)
                document.body.appendChild(a)
            }
            a.srcObject = e.streams[0]
            a.play().catch(err => log('audio.play blocked', err?.name || err))
        }

        pc.onicecandidate = (e) => {
            if (e.candidate) ws.send(JSON.stringify({ type: 'signal', target: peerId, data: { candidate: e.candidate } }))
        }

        if (isInitiator) {
            const offer = await pc.createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: false })
            await pc.setLocalDescription(offer)
            ws.send(JSON.stringify({ type: 'signal', target: peerId, data: { sdp: pc.localDescription } }))
        }
        return pc
    }

    async function handleSignal(from, data) {
        let pc = peers.get(from)
        if (!pc) pc = await connectTo(from, false)

        if (data.sdp) {
            const desc = new RTCSessionDescription(data.sdp)

            if (desc.type === 'offer' && pc.signalingState !== 'stable') {
                try { await pc.setLocalDescription({ type: 'rollback' }) } catch {}
            }
            if (desc.type === 'answer' && pc.signalingState !== 'have-local-offer') {
                return
            }

            await pc.setRemoteDescription(desc)

            if (desc.type === 'offer') {
                const answer = await pc.createAnswer()
                await pc.setLocalDescription(answer)
                ws.send(JSON.stringify({ type: 'signal', target: from, data: { sdp: pc.localDescription } }))
            }
        } else if (data.candidate) {
            try { await pc.addIceCandidate(new RTCIceCandidate(data.candidate)) }
            catch (e) { log('addIceCandidate error', e) }
        }
    }

    function closePeer(id) {
        const pc = peers.get(id)
        if (pc) { pc.getSenders().forEach(s => s.track?.stop()); pc.close(); peers.delete(id) }
        const el = streams.get(id); if (el) { el.srcObject = null; el.remove(); streams.delete(id) }
    }
</script>
